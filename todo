. .
. . + .
	.

. . 
	.
	. . . 
.
.  .
investigate sanity of how youre showing views (on memory)
	. . . 

. . .
.  .   

.
	. . . . .
				. .
colored words on turn summaries
		. . .
stop the game after `n` rounds (var in server)
.
	.
	.
	.
 .. 	

 		.
	server gives starter points at the beginning of each round

	match screenshots as closely as possible..

server 'start game' message
	first hook for bot action

a 'join' view / routine .. test it

	question:
		if someone entrusts 0 points to you, what does it do?

	lets make conditions (just 50/50 hi/lo heartrate 4 now)
display heartrates <- bot 
	lets make bot brains
'brains' can be gaussian distributions

validate user inputs
	entrust amount should be a number dial
	'entrust amount' should be w/i range
	'entrust nothing' -> 0
	login with existing id == retrieve your game state ?


log all the data

order some arduino parts



survey is part of this:
	ONE object with all the questions
	yields form AND schema for storing it

try tape
	http://www.macwright.org/2014/03/11/tape-is-cool.html
	https://github.com/substack/faucet

remember visions ->
	.
	an easy config file for bots
	games is current state - old turns, save then forget them
	server emits a Start Game message





data collection specs:
	for each round: 
			1 row:
				unique ID
				station #
				round #
				how much did i entrust
				how much did bot entrust
				did i c or d
				did bot c or d
				1/0 condition variables
				heartrate value
				bank value
				TIME beginning/end




FAQ: 
	when does bot get paired with a user? 
		on login

	when is the bots "play" launched?
		wherever a turn is handled		

	when is turn reset/data stored?
		in checkRoundCompletion()

	when is bank calculated?
		in freshRound()




the client/server API :  

	from server to player web frontend
		startEntrustTurn:
			points: 10
		startCooperateDefectTurn:
			&decision: entrust  # <- this is opponent's entrust turn
			&pointsEntrusted: 5 # <- this is opponent's entrust turn
		roundSummary:
			summary: whatever whatever 
			bank: 50

	to server from player frontend
	and from bot
		cooperateTurn:
			decision: cooperate
		entrustTurn:
			&decision: entrust
			&pointsEntrusted: 5
		readyForNextRound:









	# ---- DEBUG ------
	# we're controlling the bot's movements by hand
	# ---- DBUG -------

	# socket.on('botReadyForNextRound', (data) -> 
	# 	# this is how the bot acts:
	# 	round = getRound(data.subject_id)
	# 	# setup entrust turn
	# 	round.bot.playEntrustTurn(round, pushGamesToAdmins, checkRoundCompletion) )
		

	# socket.on('botEntrustTurn', (data) -> 
	# 	round = getRound(data.subject_id)
	# 	# setup cooperate/defect turn
	# 	round.bot.playCooperateDefectTurn(round, pushGamesToAdmins, checkRoundCompletion) )
		

	# socket.on('botCooperateDefectTurn', (data) -> 
	# 	round = getRound(data.subject_id)
	# 	# setup "ready for next round" message
	# 	round.bot.playReadyForNextRound(round, pushGamesToAdmins, checkRoundCompletion) ))



	# ---- DEBUG ------
	# We're faking the server's messages
	# when /admin emits a turn event
	# we pass that turn on to everyone in the player namespace
	# ---- DBUG -------

	# socket.on('opponentReadyForNextRound', (turn) -> 
	# 	console.log 'admin ready 4 next round'
	# 	players_ns.emit('opponentReadyForNextRound')) 

	# socket.on('opponentEntrustTurn', (turn) -> 
	# 	console.log 'admin entrust T U R N ', turn
	# 	players_ns.emit('opponentEntrustTurn', turn))

	# socket.on('roundSummary', (summary) -> 
	# 	console.log 'admin S U M M A R Y ',summary 
	# 	players_ns.emit('roundSummary', summary)))
