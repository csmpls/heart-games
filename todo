
. .
. . + .
	.


. . 
	.
	. . . 
.


	a 'header' with bank, subject, station	
	views have real buttons
	and data <- back

server maintains this games state
a 'join' view / routine - admin starts game


	food for thoughts
	turns should look the same when they are sent + received - server shouldnt alter turns at all
	so, it should send another payload (summary, bank data) at the right times

"start game" stream
streams of "turns"




try tape
	http://www.macwright.org/2014/03/11/tape-is-cool.html
	https://github.com/substack/faucet



specs:
	enter ID, it says "waiting for opponent"
	i show him the admin interface - your ID is there + your current status
	i press a button that changes his status
	he moves we repeat.
	i show him i can change the view real time 



next time ->
	turns get stored in state
	bots play turns, and a way to visualize that
	save turn in a db then forget the turn
	all the games in separate rooms
	server emits a Start Game message
	calculate game stuff, validate user inputs





# once the game starts,
# we start listening for opponents turns
startGameStream

	# (note that the server won't send opponent turns
	# until both our and the opponent's turn has been submitted)
	.onValue((v) ->

		# when opponent's "ready" for the next turn msg comes in, 
		# show the entrust view
		turnStream.filter(readyForNextTurn)
			.onValue((v) -> showEntrustView(v))

		# when opponent's "entrust" turn comes in, 
		# show the cooperate/defect view
		turnStream.filter(entrustTurn)
			.onValue((v) -> showCooperateView(v))

		# when opponent's "cooperate/defect" turn message comes in,
		# show the summary view
		turnStream.filter(cooperateDefectTurn)
			.onValue((v) -> showSummaryView(v)))