. .
. . + .
	.

. . 
	.
	. . . 
.
.  .
investigate sanity on memory) of how youre changing views
	. . . 
. . .
.  .   

.
	. . . . .
				. .
colored words on turn summaries
stop the game after `n` rounds (var in server)
.
	.
	.
	.
 .. 	
 		.
.
	.		

. . . .
	.
. .
.
.
.
 .

. .
	.
	TODO: 'noise' on tit for tat?
. .
.
	. . .



log all the data

make sure these are real sockets


validate user inputs
	entrust amount should be a number dial
	'entrust amount' should be w/i range
	'entrust nothing' -> 0

if someone entrusts 0 points to you, what should it show the opponent?

a 'join' view / routine .. test it
	joining depends on server response
	(what happens when i join a game that already exists?
		if the player is connected, go awaay
		if not, give that games state...somehow...)




front-end stylez '
	(colored words)

.

survey is part of this:
	ONE object with all the questions
	yields form AND schema for storing it






data collection specs:
	for each round: 
			1 row:
				unique ID
				station #
				round #
				how much did i entrust
				how much did bot entrust
				did i c or d
				did bot c or d
				1/0 condition variables
				heartrate value
				bank value
				TIME beginning/end




FAQ: 
	when does bot get paired with a user? 
		on login

	when is the bots "play" launched?
		wherever a turn is handled		

	when is turn reset/data stored?
		in checkRoundCompletion()

	when is bank calculated?
		in freshRound()




the client/server API :  

	from server to player web frontend
		startEntrustTurn:
			points: 10
		startCooperateDefectTurn:
			&decision: entrust  # <- this is opponent's entrust turn
			&pointsEntrusted: 5 # <- this is opponent's entrust turn
		roundSummary:
			summary: whatever whatever 
			bank: 50
			opponentHeartrate: {mean:, std:, interpretation:}

	to server from player frontend
	and from bot
		cooperateTurn:
			decision: cooperate
		entrustTurn:
			&decision: entrust
			&pointsEntrusted: 5
		readyForNextRound:








