
specs:

	ID / station / bank / 

	total points == points in this round
	updates live

	total points -> bank after each round

	we want to know all their decisions
	including their bank

	for each round: 
			1 row:
				unique ID
				station #
				round #
				how much did i entrust
				how much did bot entrust
				did i c or d
				did bot c or d
				1/0 condition variables
				heartrate value
				bank value

	survey module in the same system (after everything)



. .
. . + .
	.

. . 
	.
	. . . 
.

	a 'header' with bank, subject, station	
	views have real buttons
	wait for turn when submit
	and data <- back

server maintains this games state
a 'join' view / routine 
assign join to a 'game' + visualize
pair me with a bot, simple one for now + visualize what the bot does

	food for thoughts:
	players turns should look the same when they are sent + received - server shouldnt mutate players turns at all
	so, servers payload != turn,but is 'interpreted' turn including 'bank' and 'summary', and so on.

"start game" stream
streams of "turns"
refactor


adminscreenspecs:
	42 - [current_turn]
		[last_turn: {player:whatever, bot:whatever}]
		[player:waiting]
		[bot: {whatever}]


try tape
	http://www.macwright.org/2014/03/11/tape-is-cool.html
	https://github.com/substack/faucet


specs:
	enter ID, it says "waiting for opponent"
	i show him the admin interface - your ID is there + your current status
	i press a button that changes his status
	he moves we repeat.
	i show him i can change the view real time 


next time ->
	turns get stored in state
	bots play turns, and a way to visualize that
	save turn in a db then forget the turn
	all the games in separate rooms
	server emits a Start Game message
	calculate game stuff, validate user inputs





# once the game starts,
# we start listening for opponents turns
startGameStream

	# (note that the server won't send opponent turns
	# until both our and the opponent's turn has been submitted)
	.onValue((v) ->

		# when opponent's "ready" for the next turn msg comes in, 
		# show the entrust view
		turnStream.filter(readyForNextTurn)
			.onValue((v) -> showEntrustView(v))

		# when opponent's "entrust" turn comes in, 
		# show the cooperate/defect view
		turnStream.filter(entrustTurn)
			.onValue((v) -> showCooperateView(v))

		# when opponent's "cooperate/defect" turn message comes in,
		# show the summary view
		turnStream.filter(cooperateDefectTurn)
			.onValue((v) -> showSummaryView(v)))